// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Verifier.sol";

/**
 * @title PasswordStrengthVerifier
 * @dev Wrapper contract that uses the auto-generated Noir verifier
 * This contract will be deployed on Zircuit testnet
 */
contract PasswordStrengthVerifier {
    // Import the auto-generated verifier
    HonkVerifier public immutable verifier;

    // Events
    event PasswordStrengthVerified(
        address indexed user,
        bytes32 indexed proofHash,
        bool isValid,
        uint256 timestamp
    );

    event VaultItemCommitted(
        address indexed owner,
        bytes32 indexed itemIdHash,
        bytes32 itemCommitment,
        string itemCipherCID,
        bool passwordStrengthVerified
    );

    // State variables
    mapping(bytes32 => bool) public verifiedProofs;
    mapping(address => uint256) public userProofCount;

    constructor() {
        verifier = new HonkVerifier();
    }

    /**
     * @dev Verifies a ZK proof of password strength using the auto-generated verifier
     * @param proof The ZK proof generated by Noir + Barretenberg
     * @param publicInputs The public inputs (should be [1] for strong password)
     * @param user The address of the user
     * @return isValid Whether the proof is valid
     */
    function verifyPasswordStrength(
        bytes calldata proof,
        bytes32[] calldata publicInputs,
        address user
    ) external returns (bool isValid) {
        // Verify the proof using the auto-generated verifier
        isValid = verifier.verify(proof, publicInputs);

        if (isValid) {
            bytes32 proofHash = keccak256(
                abi.encodePacked(proof, publicInputs)
            );
            verifiedProofs[proofHash] = true;
            userProofCount[user]++;

            emit PasswordStrengthVerified(
                user,
                proofHash,
                isValid,
                block.timestamp
            );
        }

        return isValid;
    }

    /**
     * @dev Commits a vault item with password strength verification
     * @param itemIdHash Hash of the item ID
     * @param itemCommitment Commitment hash of the item
     * @param itemCipherCID IPFS CID of the encrypted item
     * @param proof ZK proof of password strength
     * @param publicInputs Public inputs for the proof
     */
    function commitVaultItem(
        bytes32 itemIdHash,
        bytes32 itemCommitment,
        string calldata itemCipherCID,
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external {
        // Verify password strength first
        bool passwordStrengthVerified = verifier.verify(proof, publicInputs);

        if (!passwordStrengthVerified) {
            revert("Password strength verification failed");
        }

        // Record the commitment
        emit VaultItemCommitted(
            msg.sender,
            itemIdHash,
            itemCommitment,
            itemCipherCID,
            passwordStrengthVerified
        );
    }

    /**
     * @dev Checks if a proof has been verified
     * @param proofHash Hash of the proof
     * @return Whether the proof has been verified
     */
    function isProofVerified(bytes32 proofHash) external view returns (bool) {
        return verifiedProofs[proofHash];
    }

    /**
     * @dev Gets the proof count for a user
     * @param user Address of the user
     * @return Number of proofs verified for the user
     */
    function getUserProofCount(address user) external view returns (uint256) {
        return userProofCount[user];
    }

    /**
     * @dev Direct verification function that can be called by other contracts
     * @param proof The ZK proof
     * @param publicInputs The public inputs
     * @return Whether the proof is valid
     */
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool) {
        return verifier.verify(proof, publicInputs);
    }
}
