# PASSWORD MANAGER

Simplified Flow for the Secure Web3 Password Vault with Privy, The Graph, IPFS, and Zircuit

A password vault with client-side encryption, ZK proofs for privacy/verification, and flows for personal/sharing.

## Simplified Complete Flow (Login + Addition + Recovery)

### Part 1: Login with Privy

- This is the first step, even before adding a password. It regenerates the encryption key for the session.
- User connects Privy wallet (e.g., via social login- gmail).
- Derives the encryption key: encryptionKey = HKDF(privyPrivateKey, salt), where salt = SHA-256(userAddress + 'vault-encryption-fixed').
- What it does: Creates a temporary key tied to the user's wallet for encryption/decryption. The key is called "temporary" because it's not stored persistently anywhere—it's generated fresh on each login and cleared from memory on logout or app close (no file/DB save, for security).
  - However, it's deterministic: The same key is recreated every time for the same user/wallet, allowing decryption of previously encrypted data.
  - This works because HKDF always outputs the same key for the same inputs (privyPrivateKey + deterministic salt).
- What is used: Privy SDK for auth/key derivation
  - SHA-256 for salt to make it user-unique without randomness.
- Where created: Client-side in the browser/app during login.
- Inputs: Privy private key (from wallet) and userAddress (from Privy) + fixed string 'vault-encryption-fixed' for domain separation.
- Why: Ensures "user owns keys" (no custodians), preparing for secure operations.
  - The deterministic salt (user-derived) must be fixed/reproducible to regenerate the exact same key on relogin—random salt would make keys different each time, preventing decryption.
  - Without this, no end-to-end privacy.
- UI: Button "Login with Privy". Post-login: "Connected."

### Part 2: Addition (Save the Password)

- This happens after login, when you add a new password. This is where the stored_hash is created and saved.

1. Input and Client-Side Encryption:
   - User enters plaintext (JSON {site, username, password}).
   - Computes stored_hash (also called the commitment) = SHA-256(plaintext) (hash of the original, ~32 bytes).
   - Encrypts: Ciphertext = AES.encrypt(plaintext, Privy key, random IV). IV is a random parameter to add noise, simple!
   - Generate ZK strength proof with circuit 1, using password as private (to verify "length >=12, has upper/lower/digit/symbol" without revealing password → which means that the proving process happens on the client side, no sent to a server, also happens off-chain, and then the verifier which is a contract verifies this on-chain).
      - This keeps proving private (user-controlled) and verification public/auditable (decentralized trust).
   - How Verification Works
      - Client-Side Proving (Off-Chain):
        - The app executes the Noir circuit locally (via WebAssembly).
        - Inputs: Private (password bytes for asserts like length/diversity); Public (commitment = SHA-256(site + username)).
        - Output: Compact SNARK proof (~200 bytes) + public signals (e.g., commitment value).
      - On-Chain Verification by Contract:
        - The verifier is a Solidity contract auto-generated by Noir (nargo codegen-verifier).
        - It uses Groth16 or PLONK (Noir's SNARK system) to mathematically check if the proof matches the circuit's rules.
        - Process: Contract computes a pairing-based check (elliptic curves math) on the proof + public signals vs. embedded verification key (vk, precomputed from circuit).
        - If valid: Tx succeeds, stores data/emits event. If invalid: Tx reverts (e.g., "Invalid proof").
        - Gas cost: Low (~50k-100k in Zircuit zk-rollup, ~$0.01).

2. Upload to IPFS:
   - Uploads ciphertext + IV (random value generated) to IPFS (via Pinata or ipfs-http-client).
   - Gets CID (e.g., "ipfs://Qm..."), a unique "address" to fetch it later.

3. On-Chain Storage in Zircuit:
   - Sends tx to the verifier contract: storeEntry(stored_hash, CID, zkProof_for_strength).
   - The contract verifies the strength proof and saves: stored_hash + CID in storage and emits event for The Graph to index).
   - This is where the stored_hash is saved: In the Zircuit contract (on-chain, public but only a hash, not the plaintext).
      - It's like a secure "fingerprint" of the original.

- Why IPFS First: IPFS is fast/off-chain for encrypted data (no gas payment). Zircuit is for small/verifiable data (hash/CID ~64 bytes), same with base is for small data.
- Timeline: All client-side + tx.

### Part 3: Recovery (Fetch and Verify)

- This happens later, when you want to see the password.
- You use what's saved to fetch and verify, starting from logging in with Privy if not already done.

1. Login with Privy (if not logged in):
   - User connects Privy wallet (e.g., via social login or EVM).
   - Derives the encryption key: encryptionKey = HKDF(privyPrivateKey, salt), where salt = SHA-256(userAddress + 'vault-encryption-fixed').

2. Query to Fetch Data:
   - Uses The Graph (GraphQL): Query { entries(user: yourAddress) { stored_hash, cid } }.
   - Gets stored_hash and CID from the Zircuit contract.

3. Fetch from IPFS:
   - Uses CID to download ciphertext + IV from IPFS.
   - you send to IPFS when adding the pasword and fetch here: IPFS is persistent storage—you upload once, download when needed (decentralized, like torrent).

4. Client-Side Decryption:
   - Recovered_plaintext = AES.decrypt(ciphertext, Privy key, IV).
   - If key/IV/ciphertext don't match, decrypt fails (error).

5. Generate ZK Integrity Proof (Circuit 2):
   - Private inputs: recovered_plaintext (hidden).
   - Public inputs: stored_hash (from query).
   - In circuit: Computes hash = SHA-256(recovered_plaintext); assert hash == stored_hash.
   - If it matches: Valid proof ("decrypt correct, nothing altered").
   - For what: Mathematically proves recovered = original, without sending plaintext on-chain.

- Why This Order (IPFS First): In recovery, you need the ciphertext to decrypt, so query first (for CID), fetch IPFS, decrypt, then ZK check with stored_hash.
- If It Fails: If ciphertext altered (e.g., hack in IPFS), hash doesn't match, proof fails—app shows error "Integrity failed".

### Why This Flow Makes Sense
- **Addition**: Saves "fingerprint" (stored_hash) on Zircuit network and "encrypted box" (ciphertext+IV in IPFS).
- **Recovery**: Fetches box, opens it, checks if fingerprint matches (ZK for privacy).
- **ZK Benefit**: The comparison is private—on-chain only sees proof "OK", not plaintext.

---

### ADDITIONAL

First, zk has two utilities: proving computation and then ensuring privacy-the later feature cus everything happens on the client side.

Zero-Knowledge (ZK) proofs add a layer of private, decentralized verification to a password manager, enabling checks on data properties (e.g., password strength or integrity) without revealing sensitive information cus everything happens on the client side, so data never leave or is sent to a server.

In our Web3 vault project, ZK transforms a traditional password manager into a trustless, privacy-focused tool, where verifications are mathematical proofs rather than server-based trusts.

1. What It Does
- What It Does: ZK allows proving statements like "this password is strong" or "the decrypted data matches the original" without exposing the password or data itself. It's like showing a lock is secure without giving away the key.

- Strength Verification: During addition, ZK proves the password meets criteria (length ≥12, includes upper/lowercase/digits/symbols, high entropy) privately.

- Integrity Verification: During recovery, ZK proves the decrypted plaintext matches the stored hash, confirming no tampering (e.g., in IPFS)

2. How It Works:
- Circuit Setup: Use Noir to create a circuit (math function) that takes private inputs (e.g., password bytes) and public inputs (e.g., a hash commitment).
- Proof Generation: Client-side (browser), the app runs the circuit: e.g., assert(length >=12) on private bytes, outputs SNARK proof (~200 bytes).
- Verification: Send proof to Zircuit contract; it verifies mathematically (cheap gas in zk-rollup) without seeing privates.
- Example: For strength, private: password; public: commitment = SHA-256(site + username). Assert diversity checks; if pass, proof valid.

3. Differentiator with Web2 and Why Use ZK + Web3
- Web2 Differentiator: Web2 managers (e.g., LastPass) are centralized: Servers store/verify data, vulnerable to hacks (e.g., LastPass breach exposed vaults).

- Checks (strength/integrity) rely on trusted custodians, risking leaks/censorship.

4. Why Use ZK + Web3:
- Privacy-by-Design: ZK proves properties publicly verifiable but privately computed—no data exposure on-chain.
- Decentralization: Web3 (Zircuit/IPFS) eliminates custodians; user owns keys (Privy) and data (client-side encrypt).
- Trustless Security: Mathematical proofs (auditable by anyone) replace server trust; scalable/low-cost in zk-rollups.
- Unique Features: Enables conditional sharing, non-custodial (no company holds keys), resistant to breaches.
- Why Implement: Demo privacy (ZK hides secrets), scalability (IPFS offloads storage), and innovation (vs. Web2's central risks).

In short, ZK + Web3 makes the manager secure, user-sovereign, and verifiable—idea trust in math, not companies.

So, in keeping with this, we should keep them simple and with the primary idea of the protocols to use.
Because it's not so much about adapting to CDP as it is about maintaining the original functionality, and the IPFS part is important, otherwise the password manager we're proposing wouldn't make sense.

This is why we should return to Privy, Zircuit, and The Graph, which are the simplest and most straightforward to use, according to this logic. 
