# Encryption Key Generation Plan (Executor)

## Goal
Derive a deterministic session encryption key on the client from the user's Privy embedded wallet, with a production-safe method, as specified in `project-overview.md`:

- Conceptual spec: `encryptionKey = HKDF(secret, salt)`
- Salt: `SHA-256(userAddress + 'vault-encryption-fixed')`

We will avoid exporting the raw private key. Instead, we use a production-compatible approach based on a deterministic wallet signature as the HKDF input keying material (IKM).

## References
- Privy React SDK docs: [https://docs.privy.io/](https://docs.privy.io/)

## Assumptions & Security Notes
- We do NOT export the raw private key in production.
- We derive a key from a deterministic, user-approved wallet signature.
- The same message signed by the same wallet should produce a deterministic signature (ECDSA RFC6979), yielding a stable IKM.
- Privy SDK + wagmi provides `signMessage` to obtain signatures.

## Data Needed
- privyPrivateKey: Hex string (32-byte ECDSA private key)
- userAddress: EVM address string (0x...)

## Derivation Details
- Salt: `SHA-256(utf8(userAddress + 'vault-encryption-fixed'))`
- HKDF hash: SHA-256
- HKDF info: `utf8('sv:hkdf:v1')` (domain separation)
- Output key length: 32 bytes (256 bits)
- IKM source (PROD): `SHA-256(signature_bytes)` where `signature_bytes` is the ECDSA signature of a fixed domain-separated message, e.g.: `"sv:derive:v1|" + userAddress`.

## Implementation Plan
1) `lib/encryption.ts`
   - Already includes: hex/utf8 helpers, `sha256Bytes`, HKDF
   - Add: `deriveEncryptionKeyFromSignature(signatureHex: string, userAddress: string)`
     - IKM = `SHA-256(signature_bytes)`
     - HKDF(salt, info='sv:hkdf:v1', len=32)

2) Production page `app/encryption/setup/page.tsx`
   - Requires login (already wrapped by `AuthGuard` in layout)
   - Uses wagmi's `useSignMessage` to sign a fixed, domain-separated message: `"sv:derive:v1|" + address`
   - Derives the key with the function above
   - Does NOT print secrets in console; shows only masked preview if needed

3) Optional (DEV-only) route `/debug/crypto` can remain for local testing, but production flow uses the signature-based method and does not rely on `NEXT_PUBLIC_DEBUG_CRYPTO`.

## Pseudocode
```ts
// lib/encryption.ts
export async function deriveEncryptionKeyFromSignature(sigHex, userAddress) {
  const sigBytes = hexToBytes(sigHex)
  const ikm = await sha256Bytes(sigBytes)
  const salt = await sha256Bytes(utf8ToBytes(userAddress + 'vault-encryption-fixed'))
  const info = utf8ToBytes('sv:hkdf:v1')
  const ikmKey = await crypto.subtle.importKey('raw', ikm, 'HKDF', false, ['deriveBits'])
  const bits = await crypto.subtle.deriveBits({ name: 'HKDF', salt, info, hash: 'SHA-256' }, ikmKey, 256)
  return new Uint8Array(bits)
}

// app/encryption/setup/page.tsx (client)
const message = `sv:derive:v1|${address}`
const { signMessageAsync } = useSignMessage()
const signature = await signMessageAsync({ message })
const key = await deriveEncryptionKeyFromSignature(signature, address)
```

## Acceptance Criteria
- Able to derive a stable 32-byte encryption key via HKDF using a wallet signature (no private key export)
- Button available at `/encryption/setup` to derive and display masked result
- No secrets printed to console

## Technical Details Explained

### What is the signature message?
When you see: `sv:derive:v1|0x074435c87FDb5342BaCE183C682475D308Ff51DE`

- `sv:derive:v1` = ShadowVault key derivation version 1 (domain separation)
- `|` = separator 
- `0x074435c87FDb5342BaCE183C682475D308Ff51DE` = Your wallet's **public address** (not private key!)

This is **safe to show** - it's your public wallet address that's already visible on the blockchain.

### What is IKM (Input Keying Material)?
IKM is the "seed" material used to generate your encryption key:
- We take your wallet signature (65 bytes of cryptographic data)
- Run it through SHA-256 to get a 32-byte hash
- This becomes the IKM for HKDF (key derivation function)
- **Why?** Same wallet signing same message = same IKM = same encryption key (deterministic)

### How is the Salt calculated?
Salt source: `userAddress + 'vault-encryption-fixed'`
Example: `0x074435c87FDb5342BaCE183C682475D308Ff51DEvault-encryption-fixed`

Then: `Salt = SHA-256(salt_source)`
Result: `d79412b8298462b9...` (first 8 bytes shown)

**Why?** 
- Makes your key unique to YOUR wallet address
- `vault-encryption-fixed` ensures domain separation (different from other apps)
- Salt prevents rainbow table attacks

### Key Derivation Flow:
1. **Message**: `sv:derive:v1|{your_address}` → Sign with wallet
2. **IKM**: `SHA-256(signature)` → 32 bytes of entropy  
3. **Salt**: `SHA-256(address + 'vault-encryption-fixed')` → Unique per user
4. **HKDF**: `HKDF(IKM, salt, info='sv:hkdf:v1')` → Final 32-byte encryption key

## Risks
- Exporting private keys is dangerous; ensure this is DEV-only. Do not ship with debug enabled.


